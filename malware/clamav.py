import collections.abc
import datetime
import functools
import hashlib
import logging
import os
import socket
import struct
import subprocess
import threading
import time

import clamav.model


logger = logging.getLogger(__name__)
CLAMAV_CFG_DEFAULT_PATH = '/etc/clamav/clamd.conf'
CLAMAV_SOCKET_DEFAULT_PATH = '/run/clamav/clamd.sock'


def _read_cfg(
    cfg_name: str,
    clamav_cfg_path: str=CLAMAV_CFG_DEFAULT_PATH,
):
    if not os.path.exists(clamav_cfg_path):
        raise ValueError(f'no cfg file at {clamav_cfg_path=}')

    with open(clamav_cfg_path, 'r') as f:
        for line in f.readlines():
            if not line.startswith(cfg_name):
                continue

            value = line.split(' ', 1)[-1].strip()
            return value

        return None # rather raise?


@functools.cache
def _lookup_clamd_socket(
    default_path: str=CLAMAV_SOCKET_DEFAULT_PATH,
    clamav_cfg_path: str=CLAMAV_CFG_DEFAULT_PATH,
) -> str:
    if os.path.isfile(clamav_cfg_path):
        # explicit configuration should win over default
        if (path := _read_cfg('LocalSocket')):
            return path

    if os.path.exists(default_path):
        return default_path

    raise ValueError('clamd socket not found')


def clamscan_version() -> clamav.model.ClamAVVersionInfo:
    clamscan_output = subprocess.check_output(
        ['clamscan', '--version'],
    ).decode()

    # example output: "ClamAV 0.105.1/26814/Thu Feb 16 08:40:04 2023/n"
    clamav_version, signature_version, signature_date = clamscan_output.strip().split('/')

    # the signature date is in ctime format. Convert to ISO 8601
    signature_date = datetime.datetime.strptime(
        signature_date, r'%a %b %d %H:%M:%S %Y'
    ).isoformat()

    signature_version = int(signature_version)

    return clamav.model.ClamAVVersionInfo(
        clamav_version_str=clamav_version,
        signature_version=signature_version,
        signature_date=signature_date,
    )


def scan(
    data: collections.abc.Iterable[bytes],
    name: str,
):
    sock = socket.socket(
        family=socket.AF_UNIX,
        type=socket.SOCK_STREAM,
    )
    clamav_socket_address = _lookup_clamd_socket()

    start_time = time.time()
    logger.debug(f'connecting to {clamav_socket_address=}')
    sock.connect(clamav_socket_address)
    sock.send(b'zINSTREAM\x00')

    total = 0
    content_hash = hashlib.sha256()

    for chunk in data:
        leng = len(chunk)
        content_hash.update(chunk)
        total += leng

        sock.send(struct.pack(b'!L', leng))
        sock.send(chunk)

    sock.send(struct.pack(b'!L', 0))

    receive_done_time = time.time()
    logger.debug(f'received {total=} octets')

    result = None

    def read_result():
        nonlocal result
        with sock.makefile('r') as f:
            result = f.read()

    reader = threading.Thread(target=read_result)
    reader.start()

    def responder(start_time):
        nonlocal result
        nonlocal content_hash

        while True:
            reader.join(timeout=20)
            if reader.is_alive():
                # still waiting for result
                logger.info('sending keep-alive..')
                continue
            break

        sock.close()

        scan_done_time = time.time()

        result = result.split(':', 1)[1][:-1].strip()

        receive_duration_seconds = receive_done_time - start_time
        scan_duration_seconds = scan_done_time - receive_done_time

        logger.info(f'scan done after {scan_duration_seconds=}')

        meta = clamav.model.Meta(
            scanned_octets=total,
            receive_duration_seconds=receive_duration_seconds,
            scan_duration_seconds=scan_duration_seconds,
            scanned_content_digest=f'sha256:{content_hash.hexdigest()}',
        )

        if result == 'OK':
            return clamav.model.ScanResult(
                status=clamav.model.ScanStatus.SCAN_SUCCEEDED,
                details='no malware was found',
                malware_status=clamav.model.MalwareStatus.OK,
                meta=meta,
                name=name,
            )

        else:
            return clamav.model.ScanResult(
                status=clamav.model.ScanStatus.SCAN_SUCCEEDED,
                details=f'malware was found: {result}',
                malware_status=clamav.model.MalwareStatus.FOUND_MALWARE,
                meta=meta,
                name=name,
            )

    return responder(start_time=start_time)
